# emacs: -*- mode: python; py-indent-offset: 4; tab-width: 4; indent-tabs-mode: nil -*-
# ex: set sts=4 ts=4 sw=4 noet:
# ## ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
#
#   See COPYING file distributed along with the datalad package for the
#   copyright and license terms.
#
# ## ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
"""High-level interface for creating a publication target on GitHub
"""

__docformat__ = 'restructuredtext'


import logging
import requests
import warnings

from datalad.interface.base import (
    build_doc,
    Interface,
)
from datalad.interface.utils import eval_results
from datalad.support.param import Parameter
from datalad.support.constraints import (
    EnsureNone,
    EnsureStr,
)
from datalad.distribution.dataset import (
    datasetmethod,
)
from datalad.distributed.create_sibling_ghlike import (
    _GitHubLike,
    _create_sibling,
)

lgr = logging.getLogger('datalad.distribution.create_sibling_github')


class _GitHub(_GitHubLike):
    name = 'github'
    fullname = 'GitHub'
    response_code_unauthorized = 401
    create_org_repo_endpoint = 'orgs/{organization}/repos'
    create_user_repo_endpoint = 'user/repos'
    get_authenticated_user_endpoint = 'user'
    get_repo_info_endpoint = 'repos/{user}/{repo}'
    extra_remote_settings = {
        # first make sure that annex doesn't touch this one
        # but respect any existing config
        'annex-ignore': 'true',
        # first push should separately push active branch first
        # to overcome github issue of choosing "default" branch
        # alphabetically if its name does not match the default
        # branch for the user (or organization) which now defaults
        # to "main"
        'datalad-push-default-first': 'true'
    }

    def repo_create_response(self, r):
        """
        At present the only difference from the GHlike implementation
        is the detection of an already existing repo in a 422 response.
        """
        try:
            response = r.json()
        except Exception as e:
            lgr.debug('Cannot get JSON payload of %s [%s]' , r, e)
            response = {}
        lgr.debug('%s responded with %s %s', self.fullname, r, response)
        if r.status_code == requests.codes.created:
            return dict(
                status='ok',
                preexisted=False,
                # perform some normalization
                reponame=response.get('name'),
                private=response.get('private'),
                clone_url=response.get('clone_url'),
                ssh_url=response.get('ssh_url'),
                html_url=response.get('html_url'),
                # and also return in full
                host_response=response,
            )
        elif r.status_code == requests.codes.unprocessable and \
                any('already exist' in e.get('message', '')
                    for e in response.get('errors', [])):
            return dict(
                status='impossible',
                message='repository already exists',
                preexisted=True,
            )
        elif r.status_code == self.response_code_unauthorized:
            return dict(
                status='error',
                message=('unauthorized: %s', response.get('message')),
            )
        # make sure any error-like situation causes noise
        r.raise_for_status()
        # catch-all
        raise RuntimeError(f'Unexpected host response: {response}')


@build_doc
class CreateSiblingGithub(Interface):
    """Create dataset sibling on GitHub.

    This command can create repositories under a user's GitHub
    account, or any organization a user is a member of (given appropriate
    permissions).

    GitHub cannot host dataset content (but LFS special remote could be used,
    http://handbook.datalad.org/r.html?LFS). However, in combination with
    other data sources (and siblings), publishing a dataset to GitHub can
    facilitate distribution and exchange, while still allowing any dataset
    consumer to obtain actual data content from alternative sources.

    For GitHub authentication a personal access token is needed.  Such a token
    can be generated by visiting https://github.com/settings/tokens or
    navigating via GitHub Web UI through: Settings -> Developer settings ->
    Personal access tokens.
    """

    _params_ = _GitHub.create_sibling_params
    # deprecated options
    _params_.update(
        github_login=Parameter(
            args=('--github-login',),
            constraints=EnsureStr() | EnsureNone(),
            metavar='TOKEN',
            doc="""Deprecated, use the credential parameter instead.
            If given must be a personal access token."""),
        github_organization=Parameter(
            args=('--github-organization',),
            constraints=EnsureStr() | EnsureNone(),
            metavar='NAME',
            doc="""Deprecated, prepend a repo name with an '<orgname>/'
            prefix instead."""),
        dryrun=Parameter(
            args=("--dryrun",),
            action="store_true",
            doc="""Deprecated. Use the renamed
            [CMD: --dry-run CMD][PY: `dry_run` PY] parameter"""),
    )

    @staticmethod
    @datasetmethod(name='create_sibling_github')
    @eval_results
    def __call__(
            reponame,
            dataset=None,
            recursive=False,
            recursion_limit=None,
            name='github',
            existing='error',
            github_login=None,
            credential=None,
            github_organization=None,
            access_protocol='https',
            publish_depends=None,
            private=False,
            dryrun=False,
            dry_run=False,
            api='https://api.github.com'):
        if dryrun and not dry_run:
            # the old one is used, and not in agreement with the new one
            warnings.warn(
                "datalad-create-sibling-github's `dryrun` option is "
                "deprecated and will be removed in a future release, "
                "use the renamed `dry_run/--dry-run` option instead.",
                DeprecationWarning)
            dry_run = dryrun

        if github_login:
            warnings.warn(
                "datalad-create-sibling-github's `github_login` option is "
                "deprecated and will be removed in a future release, "
                "use the `credential` option instead.",
                DeprecationWarning)
            from unittest.mock import patch

            # shoehorn the token into an env var to read it out using the
            # normal procedures internally
            with patch.dict(
                    'os.environ',
                    {'DATALAD_CREDENTIAL_GITHUBLOGINARG_TOKEN': github_login}):
                platform = _GitHub(
                    api, 'githubloginarg', require_token=not dry_run),
        else:
            platform = _GitHub(api, credential, require_token=not dry_run),

        if github_organization:
            warnings.warn(
                "datalad-create-sibling-github's `github_organization` "
                "option is deprecated and will be removed in a future "
                "release, prefix the reposity name with `<org>/` instead.",
                DeprecationWarning)
            reponame = f'{github_organization}/{reponame}'

        yield from _create_sibling(
            platform=platform,
            reponame=reponame,
            dataset=dataset,
            recursive=recursive,
            recursion_limit=recursion_limit,
            name=name,
            existing=existing,
            access_protocol=access_protocol,
            publish_depends=publish_depends,
            private=private,
            dry_run=dry_run,
        )
