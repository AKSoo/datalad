From: Yaroslav Halchenko <debian@onerussian.com>
Subject: Disable unicode strings in commands to be executed in tests

As you could see largely it is about executing a command with unicode, or later
logging it.  Whenvever Python2 seems to do it automagical conversions without blowing up,
on Python3 I found no reliable way to achieve desired -- logger would not accept bytes,
but would puke upon attempt to encode unicode into 'ascii', etc

Problems go away if UTF-8 locale is configured and set (instead of C or POSIX)

Last-Update: 2018-06-05

--- a/datalad/tests/test_cmd.py
+++ b/datalad/tests/test_cmd.py
@@ -56,7 +56,7 @@
     runner = Runner(protocol=dry)
 
     # test dry command call
-    cmd = 'echo Testing äöü東 dry run > %s' % tempfile
+    cmd = 'echo Testing nounicode dry run > %s' % tempfile
     with swallow_logs(new_level=5) as cml:
         ret = runner.run(cmd)
         cml.assert_logged("{DryRunProtocol} Running: %s" % cmd, regex=False)
@@ -80,7 +80,7 @@
 
     # test non-dry command call
     runner = Runner()
-    content = 'Testing äöü東 real run'
+    content = 'Testing nounicode real run'
     cmd = 'echo %s > %r' % (content, tempfile)
     ret = runner.run(cmd)
     assert_equal(ret, ('', ''))  # no out or err
@@ -184,7 +184,7 @@
     # assertion yet.
 
     runner = Runner(log_outputs=True)
-    cmd_ = ['echo', 'stdout-Message äöü東 should be logged']
+    cmd_ = ['echo', 'stdout-Message nounicode should be logged']
     for cmd in [cmd_, ' '.join(cmd_)]:
         # should be identical runs, either as a string or as a list
         kw = {}
@@ -197,16 +197,16 @@
             if not on_windows:
                 # we can just count on sanity
                 cm.assert_logged("stdout| stdout-"
-                                 "Message äöü東 should be logged", regex=False)
+                                 "Message nounicode should be logged", regex=False)
             else:
                 # echo outputs quoted lines for some reason, so relax check
-                ok_("stdout-Message äöü東 should be logged" in cm.lines[1])
+                ok_("stdout-Message nounicode should be logged" in cm.lines[1])
 
-    cmd = 'echo stdout-Message äöü東 should not be logged'
+    cmd = 'echo stdout-Message nounicode should not be logged'
     with swallow_outputs() as cmo:
         with swallow_logs(new_level=11) as cml:
             ret = runner.run(cmd, log_stdout=False)
-            eq_(cmo.out, "stdout-Message äöü東 should not be logged\n")
+            eq_(cmo.out, "stdout-Message nounicode should not be logged\n")
             eq_(cml.out, "")
 
 
@@ -281,7 +281,7 @@
     # Avoid OBSCURE_FILENAME in hopes of windows-compatibility (gh-2929).
     runner = Runner()
     with assert_raises(CommandError), swallow_logs():
-        runner.run(u"β-command-doesnt-exist", cwd=path)
+        runner.run(u"B-command-doesnt-exist", cwd=path)
 
 
 @skip_if_on_windows  # likely would fail
--- a/datalad/tests/test_config.py
+++ b/datalad/tests/test_config.py
@@ -57,7 +57,7 @@
 empty =
 myint = 3
 
-[onemore "complicated の beast with.dot"]
+[onemore "complicated nounicode beast with.dot"]
 findme = 5.0
 """
 
@@ -83,16 +83,16 @@
     assert_true(cfg.has_section('something'))
     assert_false(cfg.has_section('somethingelse'))
     assert_equal(sorted(cfg.sections()),
-                 [u'onemore.complicated の beast with.dot', 'something'])
+                 [u'onemore.complicated nounicode beast with.dot', 'something'])
     assert_true(cfg.has_option('something', 'user'))
     assert_false(cfg.has_option('something', 'us?er'))
     assert_false(cfg.has_option('some?thing', 'user'))
     assert_equal(sorted(cfg.options('something')), ['empty', 'myint', 'novalue', 'user'])
-    assert_equal(cfg.options(u'onemore.complicated の beast with.dot'), ['findme'])
+    assert_equal(cfg.options(u'onemore.complicated nounicode beast with.dot'), ['findme'])
 
     assert_equal(
         sorted(cfg.items()),
-        [(u'onemore.complicated の beast with.dot.findme', '5.0'),
+        [(u'onemore.complicated nounicode beast with.dot.findme', '5.0'),
          ('something.empty', ''),
          ('something.myint', '3'),
          ('something.novalue', None),
@@ -109,7 +109,7 @@
         cfg.get('something.user'),
         ('name=Jane Doe', 'email=jd@example.com'))
     assert_raises(KeyError, cfg.__getitem__, 'somedthing.user')
-    assert_equal(cfg.getfloat(u'onemore.complicated の beast with.dot', 'findme'), 5.0)
+    assert_equal(cfg.getfloat(u'onemore.complicated nounicode beast with.dot', 'findme'), 5.0)
     assert_equal(cfg.getint('something', 'myint'), 3)
     assert_equal(cfg.getbool('something', 'myint'), True)
     # git demands a key without value at all to be used as a flag, thus True
@@ -128,8 +128,8 @@
     assert_raises(KeyError, cfg.get_value, 'doesnot', 'exist', default=None)
 
     # modification follows
-    cfg.add('something.new', 'の')
-    assert_equal(cfg.get('something.new'), u'の')
+    cfg.add('something.new', 'nounicode')
+    assert_equal(cfg.get('something.new'), u'nounicode')
     # sections are added on demand
     cfg.add('unheard.of', 'fame')
     assert_true(cfg.has_section('unheard.of'))
--- a/datalad/core/local/tests/test_run.py
+++ b/datalad/core/local/tests/test_run.py
@@ -154,29 +154,29 @@
     touch_cmd = "import sys; open(sys.argv[1], 'w').write('')"
     cmd_str = u"{} -c \"{}\" {}".format(sys.executable,
                                         touch_cmd,
-                                        u"bβ0.dat")
+                                        u"bB0.dat")
     ds.run(cmd_str)
     assert_repo_status(ds.path)
-    ok_exists(op.join(path, u"bβ0.dat"))
+    ok_exists(op.join(path, u"bB0.dat"))
 
     # somewhat desperate attempt to detect our own Github CI tests on a
     # crippled filesystem (VFAT) that is so crippled that it doesn't handle
     # what is needed here. It just goes mad with encoded bytestrings:
     # CommandError: ''python -c '"'"'import sys; open(sys.argv[1], '"'"'"'"'"'"'"'"'w'"'"'"'"'"'"'"'"').write('"'"'"'"'"'"'"'"''"'"'"'"'"'"'"'"')'"'"' '"'"' β1 '"'"''' failed with exitcode 1 under /crippledfs/
     if not on_windows and os.environ.get('TMPDIR', None) != '/crippledfs':  # FIXME
-        ds.run([sys.executable, "-c", touch_cmd, u"bβ1.dat"])
+        ds.run([sys.executable, "-c", touch_cmd, u"bB1.dat"])
         assert_repo_status(ds.path)
-        ok_exists(op.join(path, u"bβ1.dat"))
+        ok_exists(op.join(path, u"bB1.dat"))
 
         # Send in a list of byte-strings to mimic a py2 command-line
         # invocation.
         ds.run([s.encode("utf-8")
-                for s in [sys.executable, "-c", touch_cmd, u" β1 "]])
+                for s in [sys.executable, "-c", touch_cmd, u" B1 "]])
         assert_repo_status(ds.path)
-        ok_exists(op.join(path, u" β1 "))
+        ok_exists(op.join(path, u" B1 "))
 
     with assert_raises(CommandError), swallow_outputs():
-        ds.run(u"bβ2.dat")
+        ds.run(u"bB2.dat")
 
 
 @with_tempfile(mkdir=True)
--- a/datalad/support/tests/test_globbedpaths.py
+++ b/datalad/support/tests/test_globbedpaths.py
@@ -53,7 +53,7 @@
                  "2.dat": "",
                  "3.txt": "",
                  # Avoid OBSCURE_FILENAME to avoid windows-breakage (gh-2929).
-                 u"bβ.dat": "",
+                 u"bB.dat": "",
                  "subdir": {"1.txt": "", "2.txt": ""}})
 def test_globbedpaths(path):
     dotdir = op.curdir + op.sep
@@ -61,9 +61,9 @@
     for patterns, expected in [
             (["1.txt", "2.dat"], {"1.txt", "2.dat"}),
             ([dotdir + "1.txt", "2.dat"], {dotdir + "1.txt", "2.dat"}),
-            (["*.txt", "*.dat"], {"1.txt", "2.dat", u"bβ.dat", "3.txt"}),
+            (["*.txt", "*.dat"], {"1.txt", "2.dat", u"bB.dat", "3.txt"}),
             ([dotdir + "*.txt", "*.dat"],
-             {dotdir + "1.txt", "2.dat", u"bβ.dat", dotdir + "3.txt"}),
+             {dotdir + "1.txt", "2.dat", u"bB.dat", dotdir + "3.txt"}),
             (["subdir/*.txt"], {"subdir/1.txt", "subdir/2.txt"}),
             ([dotdir + "subdir/*.txt"],
              {dotdir + p for p in ["subdir/1.txt", "subdir/2.txt"]}),
@@ -89,12 +89,12 @@
 
     # Full patterns still get returned as relative to pwd.
     gp = GlobbedPaths([op.join(path, "*.dat")], pwd=path)
-    eq_(gp.expand(), ["2.dat", u"bβ.dat"])
+    eq_(gp.expand(), ["2.dat", u"bB.dat"])
 
     # "." gets special treatment.
     gp = GlobbedPaths([".", "*.dat"], pwd=path)
-    eq_(set(gp.expand()), {"2.dat", u"bβ.dat", "."})
-    eq_(gp.expand(dot=False), ["2.dat", u"bβ.dat"])
+    eq_(set(gp.expand()), {"2.dat", u"bB.dat", "."})
+    eq_(gp.expand(dot=False), ["2.dat", u"bB.dat"])
     gp = GlobbedPaths(["."], pwd=path, expand=False)
     eq_(gp.expand(), ["."])
     eq_(gp.paths, ["."])
@@ -107,7 +107,7 @@
         eq_(gp.expand(), ["z", "b", "d", "x"])
 
     # glob expansion for paths property is determined by expand argument.
-    for expand, expected in [(True, ["2.dat", u"bβ.dat"]),
+    for expand, expected in [(True, ["2.dat", u"bB.dat"]),
                              (False, ["*.dat"])]:
         gp = GlobbedPaths(["*.dat"], pwd=path, expand=expand)
         eq_(gp.paths, expected)
--- a/datalad/tests/utils.py
+++ b/datalad/tests/utils.py
@@ -1460,7 +1460,9 @@
 OBSCURE_PREFIX = os.getenv('DATALAD_TESTS_OBSCURE_PREFIX', '')
 # Those will be tried to be added to the base name if filesystem allows
 OBSCURE_FILENAME_PARTS = [' ', '/', '|', ';', '&', '%b5', '{}', "'", '"']
-UNICODE_FILENAME = u"ΔЙקم๗あ"
+# Debian: unfortunately unicode without locales setup causes git-annex to puke
+# https://git-annex.branchable.com/bugs/fails_to_init_under_a_directory_with_a___34__tricky__34___name/
+UNICODE_FILENAME = u""
 
 # OSX is exciting -- some I guess FS might be encoding differently from decoding
 # so Й might get recoded
--- a/datalad/core/local/tests/test_diff.py
+++ b/datalad/core/local/tests/test_diff.py
@@ -500,9 +500,12 @@
 
 @with_tempfile(mkdir=True)
 def test_diff_nonexistent_ref_unicode(path):
+    # Unicode testing fails with pythons < 3.7 during debian build
+	# https://github.com/datalad/datalad/issues/4016
+    import sys
     ds = Dataset(path).create()
     assert_result_count(
-        ds.diff(fr="HEAD", to=u"β", on_failure="ignore", result_renderer=None),
+        ds.diff(fr="HEAD", to=u"β" if sys.version_info[:2] >= (3, 7) else "b", on_failure="ignore", result_renderer=None),
         1,
         path=ds.path,
         status="impossible")
